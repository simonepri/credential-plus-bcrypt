'use strict';

const bcrypt = require('bcrypt');

/**
 * Default configurations used to generate a new hash.
 * @private
 * @type {Object}
 */
const defaultConfigs = {
  // The cost of processing the data.
  // See here https://www.npmjs.com/package/bcrypt#a-note-on-rounds
  rounds: 10,
};

/**
 * Applies the hashing algorithm to the provided password.
 * @public
 * @param  {string} password The password to hash.
 * @param  {Object} [options] Configurations passed to the hashing function.
 * @param  {number} [options.rounds] The number of iterations as 2^rounds.
 * @return {Promise.<string>} The generated hash string.
 */
function hash(password, options) {
  if (typeof password !== 'string' || password.length === 0) {
    return Promise.reject(
      new TypeError('Password must be a non-empty string.')
    );
  }
  if (options !== undefined && typeof options !== 'object') {
    return Promise.reject(new TypeError('Options must be an object.'));
  }

  const cfgs = Object.assign(defaultConfigs, options);

  return bcrypt.genSalt(cfgs.rounds).then(salt => bcrypt.hash(password, salt));
}

/**
 * Determines whether the user's input matches the stored password or not.
 * @public
 * @param  {string} hash The hash string generated by this package.
 * @param  {string} password The user's password input.
 * @return {Promise.<boolean>} A boolean that is true if the hash computed for
 * the password matches the provided hash.
 */
function verify(hash, password) {
  if (typeof hash !== 'string' || hash.length === 0) {
    return Promise.reject(new TypeError('Hash must be a non-empty string.'));
  }
  if (typeof password !== 'string' || password.length === 0) {
    return Promise.reject(
      new TypeError('Password must be a non-empty string.')
    );
  }

  return bcrypt.compare(password, hash);
}

module.exports = {
  hash,
  verify,
};
